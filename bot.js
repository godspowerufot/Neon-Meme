import TelegramBot from "node-telegram-bot-api";
import { ethers } from "ethers";
import * as dotenv from "dotenv";
import { readFileSync } from "fs";
import path from "path";
import { fileURLToPath } from "url";

dotenv.config();

// === ENV VARS ===
const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
const NEON_RPC = process.env.NEON_RPC || "https://devnet.neonevm.org";
const CONTRACT_ADDRESS = process.env.CONTRACT_ADDRESS;
const PRIVATE_KEY = process.env.PRIVATE_KEY_OWNER;

// === CHECK ENV ===
if (!TELEGRAM_BOT_TOKEN) {
  console.error("‚ùå Missing TELEGRAM_BOT_TOKEN in .env");
  process.exit(1);
}
if (!CONTRACT_ADDRESS) {
  console.error("‚ùå Missing CONTRACT_ADDRESS in .env");
  process.exit(1);
}
if (!PRIVATE_KEY) {
  console.error("‚ùå Missing PRIVATE_KEY_OWNER in .env");
  process.exit(1);
}

// === PATHS & ABI ===
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const ABI_PATH = path.join(__dirname, "MemeLaunchpad.json");
const ABI = JSON.parse(readFileSync(ABI_PATH, "utf8")).abi;

// === Ethers Setup ===
const provider = new ethers.JsonRpcProvider(NEON_RPC, {
  name: "neondevnet",
  chainId: 245022926,
});
const wallet = new ethers.Wallet(PRIVATE_KEY, provider);
const contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, provider);
const contractWithSigner = new ethers.Contract(CONTRACT_ADDRESS, ABI, wallet);

// === EXPLORER URLS ===
const EXPLORER_TX_URL = "https://neon-devnet.blockscout.com/tx/";
const EXPLORER_ADDRESS_URL = "https://neon-devnet.blockscout.com/address/";

// === HELPER FUNCTIONS ===
const formatValue = (v, d = 9) => ethers.formatUnits(v, d);
const parseValue = (v, d = 9) => ethers.parseUnits(v.toString(), d);

// Helper function to create clickable links
const createTxLink = (hash) => `[${hash}](${EXPLORER_TX_URL}${hash})`;
const createAddressLink = (address) =>
  `[${address}](${EXPLORER_ADDRESS_URL}${address})`;

// === Create Telegram Bot ===
const bot = new TelegramBot(TELEGRAM_BOT_TOKEN, { polling: true });

// === USER SESSION STATE ===
const sessions = {};

// === MAIN KEYBOARD ===
const mainKeyboard = {
  reply_markup: {
    inline_keyboard: [
      [
        { text: "üìä Contract Info", callback_data: "contract_info" },
        { text: "üîç Token Info", callback_data: "token_info" },
      ],
      [
        { text: "üí∞ Calculate Buy", callback_data: "calculate_buy" },
        { text: "üöÄ Create Token Sale", callback_data: "create_token" },
      ],
      [
        { text: "üõí Buy Tokens", callback_data: "buy_tokens" },
        { text: "üíé Claim Fees", callback_data: "claim_fees" },
      ],
      [
        { text: "‚öôÔ∏è Set Fee %", callback_data: "set_fee" },
        { text: "üîß Wallet Setup", callback_data: "wallet_setup" },
      ],
      [
        { text: "ü©∫ Debug Buy", callback_data: "debug_buy" },
        { text: "‚ùì Help", callback_data: "help" },
      ],
    ],
  },
};

// === START COMMAND ===
bot.onText(/\/start/, async (msg) => {
  const chatId = msg.chat.id;
  const blockNumber = await provider.getBlockNumber();

  const welcomeMessage = `
üöÄ *Meme Launchpad Bot*

‚úÖ Connected to *Neon Devnet*
üìç Contract: \`${CONTRACT_ADDRESS}\`
üë§ Wallet: \`${wallet.address}\`
‚õìÔ∏è Current Block: ${blockNumber}

Choose an action below:
`;

  bot.sendMessage(chatId, welcomeMessage, {
    parse_mode: "Markdown",
    ...mainKeyboard,
  });
});

// === HELP COMMAND ===
bot.onText(/\/help/, (msg) => {
  bot.sendMessage(
    msg.chat.id,
    `
üìñ *Help Menu*

‚Ä¢ üìä Contract Info ‚Üí Shows contract details  
‚Ä¢ üîç Token Info ‚Üí Enter token address ‚Üí Shows sale details  
‚Ä¢ üí∞ Calculate Buy ‚Üí Enter token & WSOL ‚Üí Estimate tokens  
‚Ä¢ üöÄ Create Token Sale ‚Üí Create a new memecoin  
‚Ä¢ üõí Buy Tokens ‚Üí Buy from an active sale  
‚Ä¢ üíé Claim Fees ‚Üí Owner only  
‚Ä¢ ‚öôÔ∏è Set Fee % ‚Üí Owner only  
‚Ä¢ üîß Wallet Setup ‚Üí Check NEON & WSOL balances  
‚Ä¢ ü©∫ Debug Buy ‚Üí Diagnose purchase issues  

All amounts are WSOL (9 decimals).
    `,
    { parse_mode: "Markdown", ...mainKeyboard }
  );
});

// === CALLBACK HANDLER ===
bot.on("callback_query", async (cb) => {
  const chatId = cb.message.chat.id;
  const userId = cb.from.id;
  const action = cb.data;

  bot.answerCallbackQuery(cb.id);

  switch (action) {
    case "contract_info":
      return showContractInfo(chatId);

    case "token_info":
      sessions[userId] = { step: "token_info" };
      bot.sendMessage(chatId, "üîç Please enter the token address:");
      break;

    case "calculate_buy":
      sessions[userId] = { step: "calc_token" };
      bot.sendMessage(chatId, "üí∞ Enter the token address to calculate:");
      break;

    case "create_token":
      sessions[userId] = { step: "create_name" };
      bot.sendMessage(chatId, "üöÄ Enter token name:");
      break;

    case "buy_tokens":
      sessions[userId] = { step: "buy_token" };
      bot.sendMessage(chatId, "üõí Enter token address:");
      break;

    case "claim_fees":
      return claimFees(chatId);

    case "set_fee":
      sessions[userId] = { step: "set_fee" };
      bot.sendMessage(chatId, "‚öôÔ∏è Enter new fee percent (basis points):");
      break;

    case "wallet_setup":
      return checkWalletSetup(chatId);

    case "debug_buy":
      sessions[userId] = { step: "debug_token" };
      bot.sendMessage(chatId, "ü©∫ Enter token address to debug:");
      break;

    case "help":
      bot.sendMessage(chatId, "Type /help for full details.");
      break;
  }
});

// === TEXT MESSAGE HANDLER (STATE MACHINE) ===
bot.on("message", async (msg) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  const text = msg.text?.trim();

  // Ignore commands like /start /help here
  if (!text || text.startsWith("/")) return;

  const session = sessions[userId];
  if (!session) {
    bot.sendMessage(chatId, "Please choose from the menu.", mainKeyboard);
    return;
  }

  try {
    // --- GET TOKEN INFO ---
    if (session.step === "token_info") {
      await showTokenInfo(chatId, text);
      delete sessions[userId];
    }

    // --- CALCULATE BUY ---
    else if (session.step === "calc_token") {
      session.token = text;
      session.step = "calc_amount";
      bot.sendMessage(chatId, "Enter WSOL amount:");
    } else if (session.step === "calc_amount") {
      if (!text || isNaN(parseFloat(text))) {
        bot.sendMessage(
          chatId,
          "‚ùå Please enter a valid number for WSOL amount:"
        );
        return;
      }
      await calculateBuy(chatId, session.token, text);
      delete sessions[userId];
    }

    // --- CREATE TOKEN SALE ---
    else if (session.step === "create_name") {
      if (!text) {
        bot.sendMessage(
          chatId,
          "‚ùå Token name cannot be empty. Please enter a name:"
        );
        return;
      }
      session.name = text;
      session.step = "create_symbol";
      bot.sendMessage(chatId, "Enter token symbol:");
    } else if (session.step === "create_symbol") {
      if (!text) {
        bot.sendMessage(
          chatId,
          "‚ùå Token symbol cannot be empty. Please enter a symbol:"
        );
        return;
      }
      session.symbol = text;
      session.step = "create_decimals";
      bot.sendMessage(chatId, "Enter token decimals (default 9):");
    } else if (session.step === "create_decimals") {
      session.decimals = text || "9";
      session.step = "create_goal";
      bot.sendMessage(chatId, "Enter funding goal (WSOL):");
    } else if (session.step === "create_goal") {
      if (!text || isNaN(parseFloat(text))) {
        bot.sendMessage(
          chatId,
          "‚ùå Please enter a valid number for funding goal:"
        );
        return;
      }
      session.goal = text;
      session.step = "create_init";
      bot.sendMessage(chatId, "Enter initial supply:");
    } else if (session.step === "create_init") {
      if (!text || isNaN(parseFloat(text))) {
        bot.sendMessage(
          chatId,
          "‚ùå Please enter a valid number for initial supply:"
        );
        return;
      }
      session.init = text;
      session.step = "create_fund";
      bot.sendMessage(chatId, "Enter funding supply:");
    } else if (session.step === "create_fund") {
      if (!text || isNaN(parseFloat(text))) {
        bot.sendMessage(
          chatId,
          "‚ùå Please enter a valid number for funding supply:"
        );
        return;
      }
      session.fund = text;
      await createTokenSale(chatId, session);
      delete sessions[userId];
    }

    // --- BUY TOKENS ---
    else if (session.step === "buy_token") {
      session.token = text;
      session.step = "buy_amount";
      bot.sendMessage(chatId, "Enter WSOL amount to spend:");
    } else if (session.step === "buy_amount") {
      if (!text || isNaN(parseFloat(text))) {
        bot.sendMessage(
          chatId,
          "‚ùå Please enter a valid number for WSOL amount:"
        );
        return;
      }
      await buyTokens(chatId, session.token, text);
      delete sessions[userId];
    }

    // --- SET FEE ---
    else if (session.step === "set_fee") {
      if (!text || isNaN(parseInt(text))) {
        bot.sendMessage(
          chatId,
          "‚ùå Please enter a valid number for fee basis points:"
        );
        return;
      }
      await setFee(chatId, text);
      delete sessions[userId];
    }

    // --- DEBUG BUY ---
    else if (session.step === "debug_token") {
      session.token = text;
      session.step = "debug_amount";
      bot.sendMessage(chatId, "Enter WSOL amount to debug:");
    } else if (session.step === "debug_amount") {
      if (!text || isNaN(parseFloat(text))) {
        bot.sendMessage(
          chatId,
          "‚ùå Please enter a valid number for WSOL amount:"
        );
        return;
      }
      await debugTokenPurchase(chatId, session.token, text);
      delete sessions[userId];
    }
  } catch (err) {
    console.error("Error in message handler:", err);
    bot.sendMessage(chatId, `‚ùå Error: ${err.message}`);
    delete sessions[userId];
  }
});

// === FUNCTIONS ===

async function showContractInfo(chatId) {
  bot.sendMessage(chatId, "üìã Fetching contract info...");
  const [owner, feePercent, fee, denom, wsol, bondingCurve, factory, payer] =
    await Promise.all([
      contract.owner(),
      contract.feePercent(),
      contract.fee(),
      contract.FEE_DENOMINATOR(),
      contract.wsolToken(),
      contract.bondingCurve(),
      contract.erc20ForSplFactory(),
      contract.getPayer(),
    ]);

  const percent = ((Number(feePercent) / Number(denom)) * 100).toFixed(2);

  const msg = `
üìä *Contract Info*
üë§ Owner: ${createAddressLink(owner)}
üí∞ Fee: ${feePercent}/${denom} (${percent}%)
üí≥ Accumulated Fee: ${formatValue(fee, 9)} WSOL
ü™ô WSOL Token: ${createAddressLink(wsol)}
üìà Bonding Curve: ${createAddressLink(bondingCurve)}
üè≠ ERC20 Factory: ${createAddressLink(factory)}
üíº Payer: \`${ethers.encodeBase58(payer)}\`
`;

  bot.sendMessage(chatId, msg, { parse_mode: "Markdown", ...mainKeyboard });
}

async function showTokenInfo(chatId, tokenAddr) {
  const info = await contract.tokens(tokenAddr);
  const neonAddr = await contract.getNeonAddress(tokenAddr);
  const states = ["NOT_CREATED", "FUNDING", "TRADING"];

  const msg = `
üìä *Token Info*
üìç Address: \`${tokenAddr}\`
üéØ Funding Goal: ${formatValue(info.fundingGoal, 9)} WSOL
üí∞ Collateral: ${formatValue(info.collateralAmount, 9)} WSOL
üì¶ Initial Supply: ${formatValue(info.initialSupply, 9)} tokens
üì¶ Funding Supply: ${formatValue(info.fundingSupply, 9)} tokens
‚ö° State: ${states[info.state]}
üîó Neon: \`${ethers.encodeBase58(neonAddr)}\`
`;

  bot.sendMessage(chatId, msg, { parse_mode: "Markdown", ...mainKeyboard });
}

async function calculateBuy(chatId, tokenAddr, wsolAmt) {
  const amtWei = parseValue(wsolAmt, 9);
  const res = await contract.calculateBuyAmount(tokenAddr, amtWei);

  const msg = `
üí∞ *Buy Calculation*
ü™ô WSOL: ${wsolAmt}
üéØ Receive: ${formatValue(res.receiveAmount, 9)} tokens
üì¶ Available: ${formatValue(res.availableSupply, 9)} tokens
üìä Total: ${formatValue(res.totalSupply, 9)} tokens
üí≥ After Fee: ${formatValue(res.contributionWithoutFee, 9)} WSOL
`;

  bot.sendMessage(chatId, msg, { parse_mode: "Markdown", ...mainKeyboard });
}

async function createTokenSale(chatId, data) {
  try {
    // Validate all required fields
    if (!data.name || !data.symbol || !data.goal || !data.init || !data.fund) {
      bot.sendMessage(
        chatId,
        "‚ùå Missing required fields. Please try again.",
        mainKeyboard
      );
      return;
    }

    // Validate numeric fields
    const decimals = parseInt(data.decimals) || 9;
    if (
      isNaN(parseFloat(data.goal)) ||
      isNaN(parseFloat(data.init)) ||
      isNaN(parseFloat(data.fund))
    ) {
      bot.sendMessage(
        chatId,
        "‚ùå Invalid numeric values. Please enter valid numbers.",
        mainKeyboard
      );
      return;
    }

    bot.sendMessage(
      chatId,
      `üöÄ Creating sale: *${data.name} (${data.symbol})*`,
      {
        parse_mode: "Markdown",
      }
    );

    // Show the parameters being used
    const summary = `
üìã *Token Sale Parameters:*
‚Ä¢ Name: ${data.name}
‚Ä¢ Symbol: ${data.symbol}
‚Ä¢ Decimals: ${decimals}
‚Ä¢ Funding Goal: ${data.goal} WSOL
‚Ä¢ Initial Supply: ${data.init} tokens
‚Ä¢ Funding Supply: ${data.fund} tokens
`;
    bot.sendMessage(chatId, summary, { parse_mode: "Markdown" });

    const tx = await contractWithSigner.createTokenSale(
      data.name,
      data.symbol,
      decimals,
      parseValue(data.goal, 9),
      parseValue(data.init, 9),
      parseValue(data.fund, 9)
    );

    bot.sendMessage(
      chatId,
      `üìù Tx submitted: ${createTxLink(tx.hash)}\n‚è≥ Waiting...`,
      {
        parse_mode: "Markdown",
      }
    );

    const receipt = await tx.wait();

    let tokenAddr = "";
    for (let log of receipt.logs) {
      try {
        const parsed = contract.interface.parseLog(log);
        if (parsed.name === "TokenSaleCreated") {
          tokenAddr = parsed.args.token;
          break;
        }
      } catch {}
    }

    bot.sendMessage(
      chatId,
      `‚úÖ Token sale created!\nüìç Address: ${
        tokenAddr ? createAddressLink(tokenAddr) : "N/A"
      }`,
      { parse_mode: "Markdown", ...mainKeyboard }
    );
  } catch (error) {
    console.error("Error creating token sale:", error);
    bot.sendMessage(
      chatId,
      `‚ùå Error creating token sale: ${error.message}`,
      mainKeyboard
    );
  }
}

async function buyTokens(chatId, tokenAddr, wsolAmt) {
  bot.sendMessage(chatId, `üõí Buying *${wsolAmt} WSOL* from \`${tokenAddr}\``, {
    parse_mode: "Markdown",
  });

  const amtWei = parseValue(wsolAmt, 9);
  const wsolContract = new ethers.Contract(
    await contract.wsolToken(),
    [
      "function allowance(address,address) view returns(uint256)",
      "function approve(address,uint256) returns(bool)",
    ],
    wallet
  );

  const allowance = await wsolContract.allowance(
    wallet.address,
    CONTRACT_ADDRESS
  );
  if (allowance < amtWei) {
    bot.sendMessage(chatId, "‚è≥ Approving WSOL...");
    const approveTx = await wsolContract.approve(
      CONTRACT_ADDRESS,
      ethers.MaxUint256
    );
    await approveTx.wait();
    bot.sendMessage(chatId, "‚úÖ WSOL approved!");
  }

  const tx = await contractWithSigner.buy(tokenAddr, amtWei);
  bot.sendMessage(chatId, `üìù Tx submitted: ${createTxLink(tx.hash)}`, {
    parse_mode: "Markdown",
  });
  const receipt = await tx.wait();

  let msg = "‚úÖ Tokens purchased!";
  for (let log of receipt.logs) {
    try {
      const parsed = contract.interface.parseLog(log);
      if (parsed.name === "TokenLiqudityAdded") {
        msg += `\nüéâ Funding goal reached!\nPool: \`${ethers.encodeBase58(
          parsed.args.poolId
        )}\``;
      }
    } catch {}
  }
  bot.sendMessage(chatId, msg, { parse_mode: "Markdown", ...mainKeyboard });
}

async function claimFees(chatId) {
  const owner = await contract.owner();
  if (wallet.address.toLowerCase() !== owner.toLowerCase()) {
    bot.sendMessage(chatId, "‚ùå Only owner can claim fees.");
    return;
  }
  bot.sendMessage(chatId, "üí∞ Claiming fees...");
  const tx = await contractWithSigner.claimTokenSaleFee();
  bot.sendMessage(chatId, `üìù Tx: ${createTxLink(tx.hash)}`, {
    parse_mode: "Markdown",
  });
  await tx.wait();
  bot.sendMessage(chatId, "‚úÖ Fees claimed!", mainKeyboard);
}

async function setFee(chatId, feePoints) {
  bot.sendMessage(chatId, `‚öôÔ∏è Setting fee: ${feePoints} bp`);
  const tx = await contractWithSigner.setFeePercent(parseInt(feePoints));
  bot.sendMessage(chatId, `üìù Tx: ${createTxLink(tx.hash)}`, {
    parse_mode: "Markdown",
  });
  await tx.wait();
  bot.sendMessage(chatId, "‚úÖ Fee updated!", mainKeyboard);
}

// === DIAGNOSTIC FUNCTIONS ===

async function checkWalletSetup(chatId) {
  try {
    bot.sendMessage(chatId, "üîç Checking wallet setup...");

    // Check Neon EVM wallet
    const balance = await provider.getBalance(wallet.address);
    const blockNumber = await provider.getBlockNumber();

    // Check WSOL setup
    const wsolAddress = await contract.wsolToken();
    const wsolContract = new ethers.Contract(
      wsolAddress,
      [
        "function balanceOf(address) view returns (uint256)",
        "function allowance(address,address) view returns (uint256)",
        "function symbol() view returns (string)",
      ],
      provider
    );

    const wsolBalance = await wsolContract.balanceOf(wallet.address);
    const wsolAllowance = await wsolContract.allowance(
      wallet.address,
      CONTRACT_ADDRESS
    );
    const wsolSymbol = await wsolContract.symbol();

    const msg = `
üîç *Wallet Setup Check*

‚úÖ *Neon EVM Wallet:*
‚Ä¢ Address: ${createAddressLink(wallet.address)}
‚Ä¢ NEON Balance: ${formatValue(balance)} NEON
‚Ä¢ Block: ${blockNumber}

ü™ô *WSOL Setup:*
‚Ä¢ Contract: ${createAddressLink(wsolAddress)}
‚Ä¢ Balance: ${formatValue(wsolBalance, 9)} ${wsolSymbol}
‚Ä¢ Allowance: ${formatValue(wsolAllowance, 9)} ${wsolSymbol}

${wsolBalance > 0 ? "‚úÖ" : "‚ùå"} WSOL Balance: ${
      wsolBalance > 0 ? "OK" : "Need tokens from faucet"
    }
${wsolAllowance > 0 ? "‚úÖ" : "‚ö†Ô∏è"} Allowance: ${
      wsolAllowance > 0 ? "OK" : "Will auto-approve on buy"
    }

üí° *Need WSOL?* Visit: https://neonfaucet.org/
`;

    bot.sendMessage(chatId, msg, { parse_mode: "Markdown", ...mainKeyboard });
  } catch (error) {
    console.error("Error checking wallet setup:", error);
    bot.sendMessage(
      chatId,
      `‚ùå Error checking wallet: ${error.message}`,
      mainKeyboard
    );
  }
}

async function debugTokenPurchase(chatId, tokenAddress, wsolAmount) {
  try {
    bot.sendMessage(
      chatId,
      `ü©∫ Debugging purchase of ${wsolAmount} WSOL from ${tokenAddress}...`
    );

    let debugReport = "üîç *Debug Report*\n\n";

    // 1. Check token state
    const tokenInfo = await contract.tokens(tokenAddress);
    const tokenStates = ["NOT_CREATED", "FUNDING", "TRADING"];

    debugReport += `üìä *Token State:*\n`;
    debugReport += `‚Ä¢ Address: ${createAddressLink(tokenAddress)}\n`;
    debugReport += `‚Ä¢ State: ${tokenStates[tokenInfo.state]}\n`;
    debugReport += `‚Ä¢ Funding Goal: ${formatValue(
      tokenInfo.fundingGoal,
      9
    )} WSOL\n`;
    debugReport += `‚Ä¢ Collateral: ${formatValue(
      tokenInfo.collateralAmount,
      9
    )} WSOL\n`;
    debugReport += `‚Ä¢ Status: ${
      tokenInfo.state === 1 ? "‚úÖ Ready for funding" : "‚ùå Not accepting funds"
    }\n\n`;

    if (tokenInfo.state !== 1) {
      debugReport += `‚ùå *ERROR:* Token is not in FUNDING state!\n`;
      bot.sendMessage(chatId, debugReport, {
        parse_mode: "Markdown",
        ...mainKeyboard,
      });
      return;
    }

    // 2. Check amount
    const amountInWei = parseValue(wsolAmount, 9);
    debugReport += `üí∞ *Amount Check:*\n`;
    debugReport += `‚Ä¢ Amount: ${wsolAmount} WSOL\n`;
    debugReport += `‚Ä¢ Wei: ${amountInWei.toString()}\n`;
    debugReport += `‚Ä¢ Status: ${
      amountInWei > 0 ? "‚úÖ Valid" : "‚ùå Invalid"
    }\n\n`;

    // 3. Check balances
    const neonBalance = await provider.getBalance(wallet.address);
    const wsolAddress = await contract.wsolToken();
    const wsolContract = new ethers.Contract(
      wsolAddress,
      [
        "function balanceOf(address) view returns (uint256)",
        "function allowance(address,address) view returns (uint256)",
      ],
      provider
    );

    const wsolBalance = await wsolContract.balanceOf(wallet.address);
    const wsolAllowance = await wsolContract.allowance(
      wallet.address,
      CONTRACT_ADDRESS
    );

    debugReport += `üíº *Balance Check:*\n`;
    debugReport += `‚Ä¢ NEON: ${formatValue(neonBalance)} NEON\n`;
    debugReport += `‚Ä¢ WSOL: ${formatValue(wsolBalance, 9)} WSOL\n`;
    debugReport += `‚Ä¢ Allowance: ${formatValue(wsolAllowance, 9)} WSOL\n`;
    debugReport += `‚Ä¢ Sufficient WSOL: ${
      wsolBalance >= amountInWei ? "‚úÖ Yes" : "‚ùå No"
    }\n\n`;

    if (wsolBalance < amountInWei) {
      debugReport += `‚ùå *ERROR:* Insufficient WSOL balance!\n`;
      debugReport += `‚Ä¢ Required: ${wsolAmount} WSOL\n`;
      debugReport += `‚Ä¢ Available: ${formatValue(wsolBalance, 9)} WSOL\n`;
      bot.sendMessage(chatId, debugReport, {
        parse_mode: "Markdown",
        ...mainKeyboard,
      });
      return;
    }

    // 4. Test calculation
    try {
      const calculation = await contract.calculateBuyAmount(
        tokenAddress,
        amountInWei
      );
      debugReport += `üßÆ *Buy Calculation:*\n`;
      debugReport += `‚Ä¢ Tokens to receive: ${formatValue(
        calculation.receiveAmount,
        9
      )}\n`;
      debugReport += `‚Ä¢ Available supply: ${formatValue(
        calculation.availableSupply,
        9
      )}\n`;
      debugReport += `‚Ä¢ After fee: ${formatValue(
        calculation.contributionWithoutFee,
        9
      )} WSOL\n`;
      debugReport += `‚Ä¢ Status: ‚úÖ Calculation successful\n\n`;
    } catch (calcError) {
      debugReport += `‚ùå *ERROR:* Calculation failed!\n`;
      debugReport += `‚Ä¢ Error: ${calcError.message}\n\n`;
      bot.sendMessage(chatId, debugReport, {
        parse_mode: "Markdown",
        ...mainKeyboard,
      });
      return;
    }

    // 5. Test gas estimation
    const contractWithSigner = new ethers.Contract(
      CONTRACT_ADDRESS,
      ABI,
      wallet
    );
    try {
      const gasEstimate = await contractWithSigner.buy.estimateGas(
        tokenAddress,
        amountInWei
      );
      debugReport += `‚õΩ *Gas Estimation:*\n`;
      debugReport += `‚Ä¢ Estimated gas: ${gasEstimate.toString()}\n`;
      debugReport += `‚Ä¢ Status: ‚úÖ Transaction should succeed\n\n`;

      debugReport += `‚úÖ *All checks passed!* Transaction should work.`;
    } catch (gasError) {
      debugReport += `‚ùå *ERROR:* Gas estimation failed!\n`;
      debugReport += `‚Ä¢ Error: ${gasError.message}\n`;

      // Try to decode common errors
      if (gasError.data) {
        const errorCodes = {
          "0xe450d38c": "InvalidTokenSale()",
          "0x340dabef": "InvalidInputAmount()",
          "0x9ebda18b": "InvalidTokenSale()",
          "0xa0fa7c8f": "InvalidTokenSaleFee()",
          "0x3ee5aeb5": "ReentrancyGuardReentrantCall()",
        };

        const errorCode = gasError.data.slice(0, 10);
        const errorName = errorCodes[errorCode];

        if (errorName) {
          debugReport += `‚Ä¢ Decoded error: ${errorName}\n`;
        }
      }
    }

    bot.sendMessage(chatId, debugReport, {
      parse_mode: "Markdown",
      ...mainKeyboard,
    });
  } catch (error) {
    console.error("Error debugging token purchase:", error);
    bot.sendMessage(chatId, `‚ùå Debug error: ${error.message}`, mainKeyboard);
  }
}

// === START BOT ===
console.log("üöÄ Meme Launchpad Telegram Bot running...");
